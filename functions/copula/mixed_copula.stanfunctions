/** @addtogroup mixed_copula Mixed Discrete-Continuous Gaussian Copula Functions
 *
 * The mixed-discrete normal copula. The method is from
 * Smith, Michael & Khaled, Mohamad. (2011). Estimation of Copula Models With Discrete Margins via Bayesian Data Augmentation.
 * Journal of the American Statistical Association. 107. 10.2139/ssrn.1937983.
 *
 * @include \copula\mixed_copula.stanfunctions
 *
 * \ingroup copula
 *  @{ */

#include distribution/multi_normal_cholesky_truncated.stanfunctions

/**
  * Normal marginal
  *
  * Standardized normal marginal for mixed continuous-discrete Gaussian
  * copula.
  *
  * @copyright Ethan Alt, Sean Pinkney 2021 \n
  *
  * @param y Real[] Array
  * @param mu_glm Row vector
  * @param sigma Real[] Array
  * @param J Integer
  * @return Vector in [0, 1] of continuous outcome
  */


matrix normal_marginal(row_vector y, row_vector mu_glm, vector sigma) {
  int J = num_elements(y);
  matrix[J, 5] rtn;
  real lb = negative_infinity();
  real ub = positive_infinity();
  real lb_ind = 0;
  real ub_ind = 0;

  for (j in 1 : J) {
    real u = Phi_approx((y[j] - mu_glm[j]) / sigma[j]);
    rtn[j] = [u, lb, ub, lb_ind, ub_ind];
  }

  return rtn;
}

/**
 * Bernoulli marginal
 *
 * Bernoulli marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *    if y == 0, upper bound at inv_Phi( y, mu )
 *    if y == 1, lower bound at inv_Phi( y - 1, mu )
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of integers
 * @param mu_glm Row vector
 * @param J Integer
 * @return Vector in [0, 1] of continuous outcome
 */
matrix bernoulli_marginal(array[] int y, row_vector mu_glm, row_vector u_raw) {
  int J = num_elements(y);
  matrix[J, 5] rtn;
  row_vector[J] mu_glm_logit = inv_logit(mu_glm);

// u, lb, ub, lb_ind, ub_ind

  for (j in 1 : J) {
    real u = u_raw[j];
    real lb;
    real ub;
    real lb_ind = 0;
    real ub_ind = 0;
    if (y[j] == 0) {
      lb = negative_infinity();
      ub = inv_Phi(bernoulli_cdf(0 | mu_glm_logit[j]));
      ub_ind = 1;
    } else {
      lb = inv_Phi(bernoulli_cdf(0 | mu_glm_logit[j]));
      ub = positive_infinity();
      lb_ind = 1;
    }
    rtn[j] = [u, lb, ub, lb_ind, ub_ind];
  }

  return rtn;
}

/**
 * Binomial marginal
 *
 * Binomial marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If y != 0, lower bound at inv_Phi(y-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param n int[] Array of numerator integers
 * @param d int[] Array of denominator integers
 * @param mu_glm Row vector
 * @param J Integer
 * @return Vector in [0, 1] of continuous outcome
 */

// u, lb, ub, lb_ind, ub_ind
matrix binomial_marginal(array[] int n, array[] int d, row_vector mu_glm, row_vector u_raw) {
  int J = num_elements(n);
  matrix[J, 5] rtn;
  row_vector[J] mu_glm_logit = inv_logit(mu_glm);

  for (j in 1 : J) {
    real u = u_raw[j];
    real lb = negative_infinity();
    real ub = inv_Phi(binomial_cdf(n[j] | d[j], mu_glm_logit[j]));
    real lb_ind = 0;
    real ub_ind = 1;
    if (n[j] > 0) {
      lb_ind = 1;
      lb = inv_Phi(binomial_cdf(n[j] - 1 | d[j], mu_glm_logit[j]));
    }
    rtn[j] = [u, lb, ub, lb_ind, ub_ind];
  }

  return rtn;
}

/**
 * Poisson marginal
 *
 * Poisson marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If y != 0, lower bound at inv_Phi(y-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of integers
 * @param mu_glm Row vector
 * @param J Integer
 * @return Vector in [0, 1] of continuous outcome
 */
matrix poisson_marginal(array[] int y, row_vector mu_glm, row_vector u_raw) {
  int J = num_elements(y);
  matrix[J, 5] rtn;
  row_vector[J] mu_glm_exp = exp(mu_glm);

  for (j in 1 : J) {
    real u = u_raw[j];
    real lb = negative_infinity();
    real ub = inv_Phi(poisson_cdf(y[j] | mu_glm_exp[j]));
    real lb_ind = 0;
    real ub_ind = 1;
    if (y[j] > 0) {
      lb_ind = 1;
      lb = inv_Phi(poisson_cdf(y[j] - 1 | mu_glm_exp[j]));
    }
    rtn[j] = [u, lb, ub, lb_ind, ub_ind];
  }

  return rtn;
}


/**
 * Mixed Copula Log-Probability Function
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param Yn real[,] 2d-Array of Normal depended variates
 * @param Yb int[,] 2d-Array of Bernoulli dependent variates
 * @param Yp int[,] 2d-Array of Poisson dependent variates
 * @param uraw_be Vector of standard uniform variates for Bernoulli margins
 * @param uraw_p Vector of standard uniform variates for Poisson margins
 * @param mu_glm Matrix of GLM means
 * @param sigma Vector of standard deviations for Gaussian variables
 * @param L Cholesky Factor Correlation
 * @param bounds_ind Matrix giving whether there is an lower([1]) or upper([2]) bound
 * @param tmvn_mu Vector of means for the Multivariate (Truncated) Gaussian, almost always 0
 * @param J Integer array specifying the number of margins for each distribution
 * @param N Integer number of observations
 * @return Real log-probability
 */
real mixed_copula_cholesky_lpdf(matrix marginals, vector tmvn_mu, matrix L) {
  int J = num_elements(tmvn_mu);
  vector[J] u = marginals[ : , 1];
  vector[J] lb = marginals[ : , 2];
  vector[J] ub = marginals[ : , 3];
  vector[J] lb_ind = marginals[ : , 4];
  vector[J] ub_ind = marginals[ : , 5];

  return multi_normal_cholesky_truncated_lpdf(u | tmvn_mu, L, lb, ub, lb_ind, ub_ind);
}

/** @} */