/** @addtogroup gaussian_copula Mixed Discrete-Continuous Gaussian Copula Functions
 *
 * The mixed-discrete normal copula. The method is from
 * Smith, Michael & Khaled, Mohamad. (2011). Estimation of Copula Models With Discrete Margins via Bayesian Data Augmentation.
 * Journal of the American Statistical Association. 107. 10.2139/ssrn.1937983.
 *
 * @include \copula\gaussian_copula.stanfunctions
 *
 * \ingroup copula
 *  @{ */

#include copula/normal_copula.stanfunctions

/**
  * Normal marginal
  *
  * Standardized normal marginal for mixed continuous-discrete Gaussian
  * copula.
  *
  * @copyright Ethan Alt, Sean Pinkney 2021 \n
  *
  * @param y row_vector of normal outcomes
  * @param mu_glm row_vector of regression means
  * @param sigma vector of outcome SD's
  * @return Matrix containing continuous outcome in [0, 1],
  *         bounds values and indicators
  */
array[] matrix normal_marginal(matrix y, matrix mu_glm, vector sigma) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  matrix[N, J] adj = rep_matrix(0, N, J);
  for (j in 1:J) {
    adj[1, j] = normal_lpdf(y[ : , j] | mu_glm[ : , j], sigma[j]);
  }

  return {  Phi_approx((y - mu_glm) ./ rep_matrix(transpose(sigma), N)), adj };
}

/**
 * Bernoulli marginal
 *
 * Bernoulli marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *    if y == 0, upper bound at inv_Phi( y, mu )
 *    if y == 1, lower bound at inv_Phi( y - 1, mu )
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of binary outcomes
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
array[] matrix bernoulli_marginal(array[,] int y, matrix mu_glm, matrix u_raw) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  matrix[N, J] mat_y = to_matrix(y);
  matrix[N, J] mat_inv_y = fabs(mat_y - 1);

  matrix[N, J] mu_glm_logit = inv_logit(mu_glm);
  matrix[N, J] Lbound = mat_y .* (1 - mu_glm_logit);
  matrix[N, J] Ubound = 1 - mat_inv_y .* mu_glm_logit;
  matrix[N, J] UmL = Ubound - Lbound;

  return { Lbound + UmL .* u_raw, log(UmL) };
}

/**
 * Binomial marginal
 *
 * Binomial marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If n != 0, lower bound at inv_Phi(n-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param n int[] Array of numerator integers
 * @param d int[] Array of denominator integers
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
array[] matrix binomial_marginal(array[,] int num, array[,] int den,
                                 matrix mu_glm, matrix u_raw) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  matrix[N, J] mu_glm_logit = inv_logit(mu_glm);
  array[2] matrix[N, J] rtn;

  for (n in 1:N) {
    for (j in 1:J) {
      real Ubound = binomial_cdf(num[n, j] | den[n, j], mu_glm_logit[n, j]);
      real Lbound = 0;
      if (num[n, j] > 0) {
        Lbound = binomial_cdf(num[n, j] - 1 | den[n, j], mu_glm_logit[n, j]);
      }
      real UmL = Ubound - Lbound;
      rtn[1][n, j] = Lbound + UmL * u_raw[n, j];
      rtn[2][n, j] = log(UmL);
    }
  }

  return rtn;
}

/**
 * Poisson marginal
 *
 * Poisson marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If y != 0, lower bound at inv_Phi(y-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of integer counts
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
array[] matrix poisson_marginal(array[,] int y, matrix mu_glm, matrix u_raw) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  matrix[N, J] mu_glm_exp = exp(mu_glm);
  array[2] matrix[N, J] rtn;

  for (n in 1:N) {
    for (j in 1:J) {
      real Ubound = poisson_cdf(y[n, j] | mu_glm_exp[n, j]);
      real Lbound = 0;
      if (y[n, j] > 0) {
        Lbound = poisson_cdf(y[n, j] - 1 | mu_glm_exp[n, j]);
      }
      real UmL = Ubound - Lbound;
      rtn[1][n, j] = Lbound + UmL * u_raw[n, j];
      rtn[2][n, j] = log(UmL);
    }
  }

  return rtn;
}


/**
 * Mixed Copula Log-Probability Function
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 *
 * @param marginals Matrix of marginal calculations, constructed by concatenating the returns
 *        from the _marginal functions
 * @param L Cholesky Factor Correlation
 * @return Real log-probability
 */
real centered_gaussian_copula_cholesky_lpdf(array[,] matrix marginals, matrix L) {
  int N = rows(marginals[1][1]);
  int J = rows(L);
  int N_marginals = size(marginals);
  matrix[N, J] U;
  real adj = 0;
  int pos = 1;
  for (m in 1:N_marginals) {
    int curr_cols = cols(marginals[m][1]);
    for (c in pos:(pos + curr_cols - 1)) {
      U[ : , c] = marginals[m][1][ : , c - (pos - 1)];
    }
    adj += sum(marginals[m][2]);
    pos += curr_cols;
  }

  return multi_normal_cholesky_copula_lpdf(U | L) + adj;
}

/** @} */
