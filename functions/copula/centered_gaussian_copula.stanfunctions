/** @addtogroup gaussian_copula Mixed Discrete-Continuous Gaussian Copula Functions
 *
 * The mixed-discrete normal copula. The method is from
 * Smith, Michael & Khaled, Mohamad. (2011). Estimation of Copula Models With Discrete Margins via Bayesian Data Augmentation.
 * Journal of the American Statistical Association. 107. 10.2139/ssrn.1937983.
 *
 * @include \copula\gaussian_copula.stanfunctions
 *
 * \ingroup copula
 *  @{ */

#include copula/normal_copula.stanfunctions

/**
  * Normal marginal
  *
  * Standardized normal marginal for mixed continuous-discrete Gaussian
  * copula.
  *
  * @copyright Ethan Alt, Sean Pinkney 2021 \n
  *
  * @param y row_vector of normal outcomes
  * @param mu_glm row_vector of regression means
  * @param sigma vector of outcome SD's
  * @return Matrix containing continuous outcome in [0, 1],
  *         bounds values and indicators
  */
array[] matrix normal_marginal(matrix y, matrix mu_glm, vector sigma) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  array[2] matrix[N, J] rtn;

  for (j in 1:J) {
    for (n in 1:N) {
      rtn[1][n,j] = Phi_approx((y[n,j] - mu_glm[n,j]) / sigma[j]);
      rtn[2][n,j] = normal_lpdf(y[n,j] | mu_glm[n,j], sigma[j]);
    }
  }

  return rtn;
}

/**
 * Bernoulli marginal
 *
 * Bernoulli marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *    if y == 0, upper bound at inv_Phi( y, mu )
 *    if y == 1, lower bound at inv_Phi( y - 1, mu )
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of binary outcomes
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
array[] matrix bernoulli_marginal(array[,] int y, matrix mu_glm, matrix u_raw) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  matrix[N, J] mu_glm_logit = inv_logit(mu_glm);
  array[2] matrix[N, J] rtn;

  for (j in 1:J) {
    for (n in 1:N) {
      real Lbound = 0;
      real Ubound = 1;
      if (y[n,j] == 0) {
        Ubound = 1 - mu_glm_logit[n,j];
      } else {
        Lbound = 1 - mu_glm_logit[n,j];
      }
      real UmL = Ubound - Lbound;
      rtn[1][n,j] = Lbound + UmL * u_raw[n,j];
      rtn[2][n,j] = log(UmL);
    }
  }

  return rtn;
}

/**
 * Binomial marginal
 *
 * Binomial marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If n != 0, lower bound at inv_Phi(n-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param n int[] Array of numerator integers
 * @param d int[] Array of denominator integers
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
array[] matrix binomial_marginal(array[,] int num, array[,] int den,
                                 matrix mu_glm, matrix u_raw) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  matrix[N, J] mu_glm_logit = inv_logit(mu_glm);
  array[2] matrix[N, J] rtn;

  for (j in 1:J) {
    for (n in 1:N) {
      real Ubound = binomial_cdf(num[n, j] | den[n, j], mu_glm_logit[n, j]);
      real Lbound = 0;
      if (num[n, j] > 0) {
        Lbound = binomial_cdf(num[n, j] - 1 | den[n, j], mu_glm_logit[n, j]);
      }
      real UmL = Ubound - Lbound;
      rtn[1][n, j] = Lbound + UmL * u_raw[n, j];
      rtn[2][n, j] = log(UmL);
    }
  }

  return rtn;
}

/**
 * Poisson marginal
 *
 * Poisson marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If y != 0, lower bound at inv_Phi(y-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of integer counts
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
array[] matrix poisson_marginal(array[,] int y, matrix mu_glm, matrix u_raw) {
  int N = rows(mu_glm);
  int J = cols(mu_glm);
  matrix[N, J] mu_glm_exp = exp(mu_glm);
  array[2] matrix[N, J] rtn;

  for (j in 1:J) {
    for (n in 1:N) {
      real Ubound = poisson_cdf(y[n, j] | mu_glm_exp[n, j]);
      real Lbound = 0;
      if (y[n, j] > 0) {
        Lbound = poisson_cdf(y[n, j] - 1 | mu_glm_exp[n, j]);
      }
      real UmL = Ubound - Lbound;
      rtn[1][n, j] = Lbound + UmL * u_raw[n, j];
      rtn[2][n, j] = log(UmL);
    }
  }

  return rtn;
}


/**
 * Mixed Copula Log-Probability Function
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 *
 * @param marginals Matrix of marginal calculations, constructed by concatenating the returns
 *        from the _marginal functions
 * @param L Cholesky Factor Correlation
 * @return Real log-probability
 */
real centered_gaussian_copula_cholesky_lpdf(array[,] matrix marginals, matrix L) {
  int N = rows(marginals[1][1]);
  int J = rows(L);
  int N_marginals = size(marginals);
  matrix[N, J] U;
  real adj = 0;
  int pos = 0;
  for (m in 1:N_marginals) {
    int curr_cols = cols(marginals[m][1]);
    for (c in 1:curr_cols) {
      U[ : , (c + pos)] = marginals[m][1][ : , c];
    }
    adj += sum(marginals[m][2]);
    pos += curr_cols;
  }

  return multi_normal_cholesky_copula_lpdf(U | L) + adj;
}

/** @} */
