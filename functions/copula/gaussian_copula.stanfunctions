/** @addtogroup gaussian_copula Mixed Discrete-Continuous Gaussian Copula Functions
 *
 * The mixed-discrete normal copula. The method is from
 * Smith, Michael & Khaled, Mohamad. (2011). Estimation of Copula Models With Discrete Margins via Bayesian Data Augmentation.
 * Journal of the American Statistical Association. 107. 10.2139/ssrn.1937983.
 *
 * @include \copula\gaussian_copula.stanfunctions
 *
 * \ingroup copula
 *  @{ */

#include distribution/multi_normal_cholesky_truncated.stanfunctions

/**
  * Normal marginal
  *
  * Standardized normal marginal for mixed continuous-discrete Gaussian
  * copula.
  *
  * @copyright Ethan Alt, Sean Pinkney 2021 \n
  *
  * @param y row_vector of normal outcomes
  * @param mu_glm row_vector of regression means
  * @param sigma vector of outcome SD's
  * @return Matrix containing continuous outcome in [0, 1],
  *         bounds values and indicators
  */
matrix normal_marginal(row_vector y, row_vector mu_glm, vector sigma) {
  int J = num_elements(y);
  matrix[J, 5] rtn;
  rtn[ : , 1] = Phi_approx(transpose(y - mu_glm) ./ sigma);
  rtn[ : , 2] = rep_vector(negative_infinity(), J);
  rtn[ : , 3] = rep_vector(positive_infinity(), J);
  rtn[ : , 4] = rep_vector(0, J);
  rtn[ : , 5] = rep_vector(0, J);

  return rtn;
}

/**
 * Bernoulli marginal
 *
 * Bernoulli marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *    if y == 0, upper bound at inv_Phi( y, mu )
 *    if y == 1, lower bound at inv_Phi( y - 1, mu )
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of binary outcomes
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
matrix bernoulli_marginal(array[] int y, row_vector mu_glm, row_vector u_raw) {
  int J = num_elements(y);
  matrix[J, 5] rtn;
  row_vector[J] mu_glm_logit = inv_logit(mu_glm);

  for (j in 1 : J) {
    real u = u_raw[j];
    real lb;
    real ub;
    real lb_ind = 0;
    real ub_ind = 0;
    if (y[j] == 0) {
      lb = negative_infinity();
      ub = inv_Phi(bernoulli_cdf(0 | mu_glm_logit[j]));
      ub_ind = 1;
    } else {
      lb = inv_Phi(bernoulli_cdf(0 | mu_glm_logit[j]));
      ub = positive_infinity();
      lb_ind = 1;
    }
    rtn[j] = [u, lb, ub, lb_ind, ub_ind];
  }

  return rtn;
}

/**
 * Binomial marginal
 *
 * Binomial marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If n != 0, lower bound at inv_Phi(n-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param n int[] Array of numerator integers
 * @param d int[] Array of denominator integers
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
matrix binomial_marginal(array[] int n, array[] int d, row_vector mu_glm, row_vector u_raw) {
  int J = num_elements(n);
  matrix[J, 5] rtn;
  row_vector[J] mu_glm_logit = inv_logit(mu_glm);

  for (j in 1 : J) {
    real u = u_raw[j];
    real lb = negative_infinity();
    real ub = inv_Phi(binomial_cdf(n[j] | d[j], mu_glm_logit[j]));
    real lb_ind = 0;
    real ub_ind = 1;
    if (n[j] > 0) {
      lb_ind = 1;
      lb = inv_Phi(binomial_cdf(n[j] - 1 | d[j], mu_glm_logit[j]));
    }
    rtn[j] = [u, lb, ub, lb_ind, ub_ind];
  }

  return rtn;
}

/**
 * Poisson marginal
 *
 * Poisson marginal for mixed continuous-discrete Gaussian
 * copula.
 *
 * The lb and ub:
 *      Always upper bound at inv_Phi( y, mu )
 *      If y != 0, lower bound at inv_Phi(y-1, mu)
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 * @param y int[] Array of integer counts
 * @param mu_glm row_vector of regression means
 * @param u_raw row_vector of nuisance latent variables
 * @return Matrix containing continuous outcome in [0, 1],
 *         bounds values and indicators
 */
matrix poisson_marginal(array[] int y, row_vector mu_glm, row_vector u_raw) {
  int J = num_elements(y);
  matrix[J, 5] rtn;
  row_vector[J] mu_glm_exp = exp(mu_glm);

  for (j in 1 : J) {
    real u = u_raw[j];
    real lb = negative_infinity();
    real ub = inv_Phi(poisson_cdf(y[j] | mu_glm_exp[j]));
    real lb_ind = 0;
    real ub_ind = 1;
    if (y[j] > 0) {
      lb_ind = 1;
      lb = inv_Phi(poisson_cdf(y[j] - 1 | mu_glm_exp[j]));
    }
    rtn[j] = [u, lb, ub, lb_ind, ub_ind];
  }

  return rtn;
}


/**
 * Mixed Copula Log-Probability Function
 *
 * @copyright Ethan Alt, Sean Pinkney 2021 \n
 *
 *
 * @param marginals Matrix of marginal calculations, constructed by concatenating the returns
 *        from the _marginal functions
 * @param tmvn_mu Vector of means for the Multivariate (Truncated) Gaussian, almost always 0
 * @param L Cholesky Factor Correlation
 * @return Real log-probability
 */
real gaussian_copula_cholesky_lpdf(matrix marginals, vector tmvn_mu, matrix L) {
  int J = num_elements(tmvn_mu);
  vector[J] u = marginals[ : , 1];
  vector[J] lb = marginals[ : , 2];
  vector[J] ub = marginals[ : , 3];
  vector[J] lb_ind = marginals[ : , 4];
  vector[J] ub_ind = marginals[ : , 5];

  return multi_normal_cholesky_truncated_lpdf(u | tmvn_mu, L, lb, ub, lb_ind, ub_ind);
}

/** @} */